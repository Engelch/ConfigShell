#!/usr/bin/env bash
# shellcheck disable=SC2086,SC2001 # using multi eval levels
#########################################################################################
# CHANGELOG
# 2.2.z:
# - add /opt/ConfigShell/bin into PATH if not yet included and if existing

#########################################################################################
# ConfigShell lib 1.1 (codebase 1.0.0)
bashLib="/opt/ConfigShell/lib/bashlib.sh"
[ ! -f "$bashLib" ] && 1>&2 echo "bash-library $bashLib not found" && exit 127
# shellcheck source=/opt/ConfigShell/lib/bashlib.sh
source "$bashLib"
unset bashLib
#########################################################################################

# MAIN ====================================================================

function usage() {
     1>&2 cat <<EOF
SYNOPSYS
    gobuild-<<type>> [OPTIONS]
DESCRIPTION
    Compile a golang application for the specific architecture. Either the architecture and OS
    is determined automatically (by calling godebug or gorelease or goupx) or it is explicitly
    set by specifying is as the command such as gobuild.debug.linux_arm64.

    Normally, by default, a local go installation is expected which is executed just by
    calling go. The can be overwritten by specifying the environment variable GoCommand.
OPTIONS
    -D  ::= enable debug
    -V  ::= show Version numer
    -f  ::= force mode, compile/build even if a binary for the current version already exists
EXIT CODES
    0   ::= result of returned execution, or from returning the version number, or the help text
    1   ::= unsupported option 
EOF
}


set -e      # exit if error

### CLI parsing
# EXIT 1 usage
# EXIT 2 wrong option
# EXIT 3 version
function parseCLIOptions() {
    while getopts "DVfh" options; do         # Loop: Get the next option;
        case "${options}" in                    # TIMES=${OPTARG}
            D)  1>&2 echo Debug enabled ; DebugFlag="TRUE"
                ;;
            V)  1>&2 echo $_appVersion
                exit 0
                ;;
            h)  usage ; exit 0
                ;;
            f)  1>&2 echo "forced mode, overwriting existing binary"
                _forceMode=TRUE
                ;;
            *)  1>&2 echo "Help with $App -h"
                exit 1
                ;;
        esac
    done
}

function main() {
    if ! [[ "$PATH" =~ '/opt/ConfigShell/bin' ]] ; then
        PATH="$PATH:/opt/ConfigShell/bin"
        debug add ConfigShell/bin to PATH
    fi
    exitIfBinariesNotFound sed version.sh

    declare -r App=$(basename "$0")
    declare -r AppDir=$(dirname "$0")
    #declare -r AppLibDir=$(dirname "$AppDir")/lib
    declare -r AppVersion="2.2.0"
    declare -r GoCmd="${GoCommand:-go}"
    _forceMode=

    #### check if the command-name is structured in such a way that we can
    #### determine the release-type and target OS and architecture by it.

    # app-specific vars
    declare -r _binDir=${BINDIR:-./build}
    declare -r _osDir=$(echo $0 | sed 's/.*\.//')
    declare -r _osType=$(echo $_osDir | sed 's/_.*//')
    # linux_arm5 introduced as support for CB1.
    # Avoidance of the introduction of a further field to the command name.
    declare -r _osArch=$(echo $_osDir | sed 's/.*_//' | sed 's/arm5$/arm/') # cb1 arm5

    if [ "$(echo $_osDir | sed 's/.*_//')" = arm5  ] ; then
        declare -r _goarm='GOARM=5'
    fi

    parseCLIOptions $@  # no parentheses required

    unset _upx
    declare -r _releaseType=$(basename $0 | cut -d . -f 2)
    case $_releaseType in
        debug)
            declare -r _ldFlags=${LDFLAGS:-}
            ;;
        release)
            declare -r _ldFlags=${LDFLAGS:-"-ldflags -w -ldflags -s"}
            ;;
        upx)
            declare -r _ldFlags=${LDFLAGS:-"-ldflags -w -ldflags -s"}
            declare -r _upx=.upx
            command -v upx > /dev/null 2>&1 || errorExit 20 upx command not found.
            ;;
        *) errorExit 2 Unsupported release-type:$_releaseType
            ;;
    esac

    declare -r _outputDir=$_binDir/$_releaseType/$_osDir
    declare -r _appName=$(pwd | xargs basename)     # app to be build
    declare -r _appVersion=$(version.sh)   # version of app to be build

    [ -z "$_appVersion" ] && errorExit 10 Could not determine the version of the go application.

    ### debug output

    debug bindir         $_binDir
    debug osdir          $_osDir
    debug ostype         $_osType
    debug osarch         $_osArch
    debug releaseType    $_releaseType
    debug ldFlags        $_ldFlags
    debug AppDir         $AppDir
    debug outputDir      $_outputDir
    debug appName        $_appName
    debug appVersion     $_appVersion
    debug goarm          $_goarm
    debug upx            $_upx

    # compiler aka host-architecture
    declare -r _hostarch=$(uname -m | tr '[:upper:]' '[:lower:]' | sed 's/x86_64/amd64/')
    declare -r _hostostype=$(uname | tr '[:upper:]' '[:lower:]')
    debug _hostarch     $_hostarch
    debug _hostostyp    $_hostostype

    debug Press ENTER to continue or ctrl-C to exit.
    debugExecIfDebug read

    [ $_releaseType = upx ] && exitIfBinariesNotFound upx
    debug passed upx check

    #### if required create the output directory and jump into it
    if [ ! -d ${_outputDir} ] ; then debug creating output directory ;  mkdir -p ${_outputDir} ; fi
    # cd ${_outputDir}
    debug passed optionally create output dir
    #### do not overwrite an existing version if not _forceMode is set
    [ -f ${_outputDir}/${_appName}-${_appVersion} ] && [ -z "${_forceMode}" ] && errorExit 10 Current version ${_appName}-${_appVersion} already exists.
    debug passed overwrite check existing versions

    echo Executing GOARCH="${_osArch}" GOOS="${_osType}" ${_goarm} "$GoCmd" build ${_ldFlags} -o "${_outputDir}/${_appName}-${_appVersion}${_upx}"
    eval GOARCH="${_osArch}" GOOS="${_osType}" ${_goarm} "$GoCmd" build ${_ldFlags} -o "${_outputDir}/${_appName}-${_appVersion}${_upx}"
    # ldflags -s is already stripping; double strip caused problems on Darwin-arm64
    # strip only if building for the same host as we are compiling on
    # [ $_hostarch = $_osArch -a $_osType = $_hostostype ] && \
    #   [ "$_releaseType" = release -o "$_releaseType" = upx ] && \
    #   echo stripping binary && strip ${_outputDir}/${_appName}-${_appVersion}${_upx}
    [ -n "${_upx}" ] && echo upx "${_outputDir}/${_appName}-${_appVersion}${_upx}" && upx "${_outputDir}/${_appName}-${_appVersion}${_upx}"
    ln -fs "${_appName}-${_appVersion}${_upx}" "${_outputDir}/${_appName}"
}

main "$*"

# EOF
