#!/usr/bin/env -S bash --norc --noprofile
# vim: set expandtab: ts=3: sw=3
# shellcheck disable=SC2155
#
# TITLE: cpkg
#
# DESCRIPTION: <see usage function below>
#
# LICENSE: MIT Â©2024 Christian ENGEL (mailto:engel-ch@outlook.com)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this
# software and associated documentation files (the "Software"), to deal in the Software
# without restriction, including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
# to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
# PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
# FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

function loadLibs() {
    #########################################################################################
    # ConfigShell lib 1.1 (codebase 1.0.0)
    bashLib="/opt/ConfigShell/lib/bashlib.sh"
    [ ! -f "$bashLib" ] && 1>&2 echo "bash-library $bashLib not found" && exit 127
    # shellcheck source=/opt/ConfigShell/lib/bashlib.sh
    source "$bashLib"
}

function usage()
{
    1>&2 cat <<HERE
NAME
    $_app
SYNOPSIS
    $_app [-D] [-f] u|up|upg|upgrade [ -f | --force | -D | --debug ] 
    $_app [-D] s|se|sea|search <<pkg>>
    $_app [-D] i|in|info <<pkg>>
    $_app [-D] a|add <<pkg>>
    $_app [-D] del|delete <<pkg>>
    $_app [-D] l|ls|lst|list [ <<pkgNameSubString>> ]
    $_app [-D] c|con|contents [ <<pkgNameSubString>> ]

    $_app [-V]
    $_app -h
VERSION
    $_appVersion
DESCRIPTION
    cpkg is Configshell's abstraction layer to the local OS upgrade
    management system. It is pluggable and can be extended.

    Besides OS packages, it upgrades in the following sequence:
        1. ConfigShell
        2. OS packages or homebrew packages (OSX)
        3. TeX-Manager installation
        4. Cargo installed applications (Rust)
        5. User-added executables in $HOME/.cpkg.d/upgrade/

            To get rid of messages for non-existing local directories, just
            create the requested directory.
OPTIONS
    -D      ::= enable debug output
    -V      ::= output the version number to stderr and exit with 0
    -h      ::= show usage message to stderr and exit with 0
    -f      ::= force installation, might overwrite other existing installations
HERE
}

# EXIT 1..
function parseCLI() {
    while getopts "DVfh" options; do         # Loop: Get the next option;
        case "${options}" in                    # TIMES=${OPTARG}
            D)  1>&2 echo Debug enabled ; DebugFlag="TRUE"
                ;;
            V)  1>&2 echo $_appVersion
                exit 0
                ;;
            f)  forceMode='--force'
                ;;
            h)  usage ; exit 0
                ;;
            # v)  verbose=TRUE
            #     ;;
            *)
                1>&2 echo "Help with $_app -h"
                exit 1  # Exit abnormally.
                ;;
        esac
    done
}

# EXIT 10..
function determineSubCmd() {
    case "${1:-}" in
    u|up|upg|upgrade) echo Upgrade
        ;;
    s|se|sea|search) echo Search
        ;;
    a|add) echo Add
        ;;
    del|delete) echo Delete
        ;;
    l|ls|lst|list) echo List
        ;;
    i|in|info) echo Info
        ;;
    c|con|contents) echo Contents
        ;;
    h|?|help) echo Help
        ;;
    *)  usage
        errorExit 10 Command ${1:-} not found.
        ;;
    esac
}

# EXIT 30..
function subSubCmdHelper() {
    [ -z "$1" ] && errorExit 30 subSubCmdHelper no command specified
    local _prog="/opt/ConfigShell/lib/cpkg/$(uname)/$1"
    shift
    if [ -x "$_prog" ] ; then  debug  "$_prog" "$@" ;  "$_prog" "$@" ; else errorExit 20 "$_prog is for the OS $(uname) not yet implemented." ; fi
}

# EXIT 40..
function subSubUserExtension() {
    [ -z "${1:-}" ] && errorExit 40 subSubUserExtension no command specified
    _localDir="$HOME/.cpkg.d/$1"
    [ ! -d "$_localDir" ] && debug no local directory $_localDir found && return
    echo local ${_localDir} ........................................................
    find "." -name '*.sh' -print0 | while IFS= read -r -d '' file; do
        [ -x "$file" ] && echo "  executing $file" && ./"$file"
        [ ! -x "$file" ] && warning file not executable "$file"
    done
}

function cargoUpdate() {
    `which cargo &>/dev/null` && debug cargo found && {
        if [ "$(cargo --list | grep -c install-update)" -gt 0 ] ; then
            echo CARGO update ..............................................................
            debug updating cargo installations
            cargo install-update -a
        else
            echo CARGO .....................................................................
            err Could find cargo but not cargo-update, consider running cargo install cargo-update
        fi
    }
}

function cmdAdd() {
    subSubCmdHelper add "$@"
    subSubUserExtension add "$@"
}

function cmdUpgrade() {
    while : ; do
        [ "${1:-}" = '-D' ] && debugSet && debug Debug enabled && shift && continue
        [ "${1:-}" = '--debug' ] && debugSet && debug Debug enabled && shift && continue
        [ "${1:-}" = '-f' ] && forceMode='--force' && debug force mode enabled && shift && continue        # compatibility help, forcing is also allowed to be defined after the subcommand
        [ "${1:-}" = '--force' ] && forceMode='--force' && debug force mode enabled && shift && continue
        break
    done     
    pkgUpgrade $forceMode
    echo rustup ..................................................................... &&
    $(which rustup &> /dev/null) && 
        rustup update
    cargoUpdate
    [ $(uname) = Darwin ] && {
        echo OSX base ..................................................................
        if which softwareupdate &>/dev/null ; then softwareupdate -ai ; else 1>&2 echo softwareupdate NOT FOUND ; fi
    }
    subSubUserExtension upgrade "$@"
}   

function cmdSearch() {
    subSubCmdHelper search "$@"
    subSubUserExtension search "$@" # potentially for statistics
}

function cmdDelete() {
    subSubCmdHelper delete "$@"
    subSubUserExtension delete "$@"
}

function cmdList() {
    subSubCmdHelper list "$@"
}

function cmdInfo() {
    subSubCmdHelper info "$@"  # potentially for statistics
}

function cmdContents() {
    subSubCmdHelper contents "$@"
}

# EXIT 1
function cmdHelp() {
    usage
    exit 1
}

function main() {
    set -u
    # Variables
    declare -r _app=$(basename "${0}")
    declare -r _appDir=$(dirname "$0")
    declare -r _absoluteAppDir=$(cd "$_appDir" || exit 99 ; /bin/pwd)
    declare -r _appVersion="0.1.1"      # use semantic versioning
    export DebugFlag=${DebugFlag:-FALSE}
    declare forceMode=''
    # verbose=

    parseCLI "$@"               # cannot use fn-s from loadLibs
    shift "$(( OPTIND - 1 ))"   # not working inside parseCLI

    loadLibs
    exitIfBinariesNotFound mktemp

    debug args are "$*"
    subCmd="$(determineSubCmd ${1:-})"
    [ -z "$subCmd" ] && exit 10 # same exit value as in determineSubCmd
    cmd="cmd$subCmd"
    shift
    debug calling function $cmd
    ${cmd} "$@"
}

main "$@"

# EOF
