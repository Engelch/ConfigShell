#!/usr/bin/env bash
# vim: set expandtab: ts=3: sw=3
#
# TITLE: $_app
#
# DESCRIPTION: <see usage function below>
#
# CHANGELOG:
# - 1.0.0: initial
#
# COPYRIGHT Â© 2022 Christian Engel (mailto:engel-ch@outlook.com)
#
# Skeleton:
# << deleted >>
#
# LICENSE: MIT
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this
# software and associated documentation files (the "Software"), to deal in the Software
# without restriction, including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
# to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
# PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
# FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

#########################################################################################
# VARIABLES, CONSTANTS

# readonly skeleton_version=0.4.1 # variable normally not required

readonly _app=$(basename $0)
readonly _appDir=$(dirname $(readlink -f $0))
readonly _appVersion="2.0.0" # use semantic versioning
export DebugFlag=${DebugFlag:-FALSE}

#########################################################################################
# SKELETON FUNCTIONS, considered R/O, v0.4.1 excerpt

# so helps to write a message in reverse mode
function so()
# always show such a message.  If known terminal, print the message
# in reverse video mode. This is the other way, not using escape sequences
{
   [ "$1" != on -a "$1" != off ] && return
    if [ "$TERM" = xterm -o "$TERM" = vt100 -o "$TERM" = xterm-256color  -o "$TERM" = screen ] ; then
      [ "$1" = on ] && tput smso
      [ "$1" = off ] && tput rmso
    fi
}

# --- debug: Conditional debugging. All commands begin w/ debug.

function debugSet()             { DebugFlag=TRUE; return 0; }
function debugUnset()           { DebugFlag=; return 0; }
function debugExecIfDebug()     { [ "$DebugFlag" = TRUE ] && $*; return 0; }
function debug()                { [ "$DebugFlag" = TRUE ] && echo 'DEBUG:'$* 1>&2 ; return 0; }
function debug4()               { [ "$DebugFlag" = TRUE ] && echo 'DEBUG:    ' $* 1>&2 ; return 0; }
function debug8()               { [ "$DebugFlag" = TRUE ] && echo 'DEBUG:        ' $* 1>&2 ; return 0; }
function debug12()              { [ "$DebugFlag" = TRUE ] && echo 'DEBUG:            ' $* 1>&2 ; return 0; }

function verbose()              { [ "$VerboseFlag" = TRUE ] && echo -n $* ; return 0; }
function verbosenl()            { [ "$VerboseFlag" = TRUE ] && echo $* ; return 0; }
function verboseSet()           { VerboseFlag=TRUE; return 0; }

# --- Exits

# function error()        { err 'ERROR:' $*; return 0; } # similar to err but with ERROR prefix and possibility to include
# Write an error message to stderr. We cannot use err here as the spaces would be removed.
function error()        { so on; echo 'ERROR:'$* 1>&2;            so off ; return 0; }
function error4()       { so on; echo 'ERROR:    '$* 1>&2;        so off ; return 0; }
function error8()       { so on; echo 'ERROR:        '$* 1>&2;    so off ; return 0; }
function error12()      { so on; echo 'ERROR:            '$* 1>&2;so off ; return 0; }

function warning()      { so on; echo 'WARNING:'$* 1>&2;          so off; return 0; }


function errorExit()    { EXITCODE=$1 ; shift; error $* ; exit $EXITCODE; }
function exitIfErr()    { a="$1"; b="$2"; shift; shift; [ "$a" -ne 0 ] && errorExit $b App returned $b $*; }

function err()          { echo $* 1>&2; }                 # just write to stderr
function err4()         { echo '   ' $* 1>&2; }           # just write to stderr
function err8()         { echo '       ' $* 1>&2; }       # just write to stderr
function err12()        { echo '           ' $* 1>&2; }   # just write to stderr

# --- Existance checks
function exitIfBinariesNotFound()       { for file in $@; do [ $(command -v "$file") ] || errorExit 253 binary not found: $file; done }
function exitIfPlainFilesNotExisting()  { for file in $*; do [ ! -f $file ] && errorExit 254 'plain file not found:'$file 1>&2; done }
function exitIfFilesNotExisting()       { for file in $*; do [ ! -e $file ] && errorExit 255 'file not found:'$file 1>&2; done }
function exitIfDirsNotExisting()        { for dir in $*; do [ ! -d $dir ] && errorExit 252 "$APP:ERROR:directory not found:"$dir; done }

# --- Temporary file/directory  creation
# -- file creation -- TMP1=$(tempFile); TMP2=$(tempFile) ;;;; trap "rm -f $TMP1 $TMP2" EXIT
# -- directory creation -- TMPDIR=$(tempDir) ;;;;;  trap "rm -fr $TMPDIR;" EXIT
#
function tempFile()                     { mktemp ${TMPDIR:-/tmp/}$_app.XXXXXXXX; }
function tempDir()                      { mktemp -d "${TMPDIR:-/tmp/}$_app.YYYYYYYYY"; }
# realpath as shell, argument either supplied as stdin or as $1

# application-specific functions  ===============================================================================

function usage()
{
    err DESCRIPTION
    err4 allow encryption of files in a git repository. Solve some problems with
    err4 git crypt, git secret, and git secrets.
    err
    err SYNOPSIS
    err4 $_app '[-D] gee init <<pwFile>>'
    err8 Put git repository under git gee => install a prehook
    err8 and specify the password file for en- and decryption.
    err
    err4 $_app gee add '<<file>> ...'
    err8 - Put file under git.
    err8 - The current contents will be copied to '<<file>>.gee' and will be encrypted
    err8 - The current '<<file>>' will be put in .gitignore
    err8 - Potentially already existing version of '<<file>>' in index will be removed rm --cached
    err
    err4 git commit ...
    err8 - gee checks for all .gee files if the ignored file without the suffix is younger than the .gee file
    err8   if existing. If so, it blocks the commit.
    err
    err4 git gee unencrypt '<<file>> ...'
    err8 - creates an uencrypted version of the file. If no argument is given, it does so for all .gee files.
    err8 - No difference if the file is specified with .gee or without it.
    err
    err4 git gee encrypt '<<file>> ...'
    err8 todo force mode?
    err8 - encrypts the specificied files.
    err8 - No difference if the file is specified with .gee or without it.
    err
    err4 git gee list
    err8 - list files under git gee
    err
    err4 git gee version
    err8 - list the current version of git gee and exits
    err
    err4 git gee help '| git gee h | git gee -h'
    err8 - show this help and exits.
    err
    err4 GLOBAL OPTIONS
    err4 '-D      ::= enable debug output'
    err4 '-h      ::= show usage message and exit with exit code 1'
}

function parseCLI() {
    while getopts "Dhv" options; do         # Loop: Get the next option;
        case "${options}" in                    # TIMES=${OPTARG}
            D)  err Debug enabled ; debugSet
                ;;
            h)  usage ; exit 1
                ;;
            v)  verboseSet
                ;;
            *)  err Help with $_app -h
                exit 2  # Exit abnormally.
                ;;
        esac
    done
}

function parseListCLI() {
    debug4 parseListCLI $* ......................
    case $1 in
    -q|q|quiet)  debug8 quiet mode in list CLI
        _quiet=-q
        shift
        parseListCLI $*
        ;;
    -d|d|dec|decr|decrypt|decrypted|-u|u|unenc|unencrypt|unencrypted)
        debug8 decrypted mode in list CLI
        [ "$_encryptedOnly" = TRUE ] && errorExit 20 encrypted und decrypted mode together
        _unencryptedOnly=TRUE
        shift
        parseListCLI $*
        ;;
    -e|e|enc|encr|encry|encryp|encrypt|encrypted|-p|p|prv|priv|private)
        debug8 decrypted mode in list CLI
        [ "$_unencryptedOnly" = TRUE ] && errorExit 21 encrypted und decrypted mode together
        _encryptedOnly=TRUE
        shift
        parseListCLI $*
        ;;
    esac
}

function checkPreCommitHookExisting() {
    readonly _hook=$(git rev-parse --show-toplevel)/.git/hooks/pre-commit
    [ -e "$_hook" -a ! -f "$_hook" ] && error Other object type with name $_hook && return 1
    [ ! -f "$_hook" ] && error Hook $_hook not found. && return 2
    [ ! -r "$_hook" ] && error Hook $_hook not readable. && return 3
    return 0
}

function exitIfNotInGitRepo() {
    git rev-parse --show-toplevel &>/dev/null || errorExit 11 Not in a git repository
}

function exitIfNotInGitGeeRepo() {
    [ ! -f $(git rev-parse --show-toplevel)/.git/gee ] && errorExit 12 Not a git gee repository
}

function git-root-relative-path () {
    local _gitroot
    local _absfile
    gitroot="$(git rev-parse --show-toplevel)"
    _absfile=$(readlink -f "$1")
    echo $_absfile | sed s,$gitroot/,,
}

function main() {
    exitIfBinariesNotFound tput basename dirname readlink git pwd
    #exitIfFilesNotExisting "$_appDir"/gee-encrypt "$_appDir"/gee-privateFiles
    parseCLI $*
    shift $(($OPTIND - 1))  # not working inside parseCLI
    debug args after CLI parsing are $*

    _mode=$1
    case $_mode in
    a|add)
        debug add mode
        exitIfNotInGitRepo
        exitIfNotInGitGeeRepo
        shift
        gitroot="$(git rev-parse --show-toplevel)"
        for file in $* ; do
            [ ! -e $file ] && errorExit 40 $file does not seem to exist
            [ ! -f $file ] && errorExit 41 $file is not a plain file
            [ -e $file.gee ] && errorExit 42 $file.gee already exists
            _gitFile=$(git-root-relative-path $file)
            if [ $(egrep $_gitFile "$gitroot/.gitignore" 2>/dev/null | wc -l) -gt 0 ] ; then
                1>&2 echo WARNING: file $file already in .gitignore
                [ ! -f "$file.gee" ] && errorExit 43 File in gitignore but no related gee file found.
                continue
            fi
            #echo $_gitFile >> "$gitroot/.gitignore"
            #git rm --cached $file &>/dev/null # remove file if potentially in index
            #cp $file $file.gee
            _geePwFile=$(dirname $gitroot)/$(basename $(git rev-parse --show-toplevel)).gee.pw
            echo $_geePwFile
            #ansible-vault encrypt --vault-password-file=. $file.gee
        done
        ;;
    h|help)
        usage
        exit 2
        ;;
    init)
        debug init mode
        exitIfNotInGitRepo
        cd $(git rev-parse --show-toplevel)
        [ ! -f ../$(basename $PWD).gee.pw ] && errorExit 30 Password file ../$(basename $PWD).gee.pw not found
        [ ! -r ../$(basename $PWD).gee.pw ] && errorExit 31 Password file ../$(basename $PWD).gee.pw not readable
        [ -f .gitignore ] && [ $(egrep '.gee$' .gitignore | wc -l) -gt 0 ] && errorExit 32 .gee files seem to be in .gitignore, please check
        touch $(git rev-parse --show-toplevel)/.git/gee # make it detectable that gee is applied
        # todo install hook
        echo todo install hook
        ;;
    l|list|lst)
        debug list mode
        shift
        exitIfNotInGitRepo
        verbosenl Listing from from git root directory:$(git rev-parse --show-toplevel)
        cd "$(git rev-parse --show-toplevel)"
        find . -type f -name '*.gee'
        ;;
    e|en|enc|encr|encry|encryp|encrypt|encrypted)
        debug encrypt mode
        exitIfNotInGitRepo
        exitIfNotInGitGeeRepo
            #git rev-parse --show-toplevel &>/dev/null || errorExit 1 Not in a git repository
    #cd "$(git rev-parse --show-toplevel)"

        # checkPreCommitHookExisting ; res=$? ; [ $res -ne 0 ] && return $res
        # "$_appDir"/gee-encrypt -e $*
        ;;
    d|de|dec|decr|decry|decryp|decrypt|u|un|une|unen|unencr|unencry|unencryp|unencrypt|unencrypted)
        debug decrypt mode
        exitIfNotInGitRepo
        exitIfNotInGitGeeRepo
        shift
            #git rev-parse --show-toplevel &>/dev/null || errorExit 1 Not in a git repository
        #cd "$(git rev-parse --show-toplevel)"

        # checkPreCommitHookExisting ; res=$? ; [ $res -ne 0 ] && return $res

        # "$_appDir"/gee-encrypt -d $*
        ;;
    version)
        echo $_appVersion
        exit 0
        ;;
    *)  [ -z "$_mode" ] && exit 0
        errorExit 10 unknown sub-command to git gee $_mode
        ;;
    esac
    return 0
}

main $*

# EOF
