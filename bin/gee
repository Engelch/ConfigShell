#!/usr/bin/env bash
# vim: set expandtab: ts=3: sw=3
#
# TITLE: $_app
#
# DESCRIPTION: <see usage function below>
#
# CHANGELOG:
# - 1.0.0: initial
#
# COPYRIGHT Â© 2022 Christian Engel (mailto:engel-ch@outlook.com)
#
# Skeleton:
# << deleted >>
#
# LICENSE: MIT
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this
# software and associated documentation files (the "Software"), to deal in the Software
# without restriction, including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
# to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
# PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
# FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

#########################################################################################
# VARIABLES, CONSTANTS

# readonly skeleton_version=0.4.1 # variable normally not required

readonly _app=$(basename $0)
readonly _appDir=$(dirname $(readlink -f $0))
readonly _appVersion="2.0.0" # use semantic versioning
export DebugFlag=${DebugFlag:-FALSE}

#########################################################################################
# SKELETON FUNCTIONS, considered R/O, v0.4.1 excerpt

# so helps to write a message in reverse mode
function so()
# always show such a message.  If known terminal, print the message
# in reverse video mode. This is the other way, not using escape sequences
{
   [ "$1" != on -a "$1" != off ] && return
    if [ "$TERM" = xterm -o "$TERM" = vt100 -o "$TERM" = xterm-256color  -o "$TERM" = screen ] ; then
      [ "$1" = on ] && tput smso
      [ "$1" = off ] && tput rmso
    fi
}

# --- debug: Conditional debugging. All commands begin w/ debug.

function debugSet()             { DebugFlag=TRUE; return 0; }
function debugUnset()           { DebugFlag=; return 0; }
function debugExecIfDebug()     { [ "$DebugFlag" = TRUE ] && $*; return 0; }
function debug()                { [ "$DebugFlag" = TRUE ] && echo 'DEBUG:'$* 1>&2 ; return 0; }
function debug4()               { [ "$DebugFlag" = TRUE ] && echo 'DEBUG:    ' $* 1>&2 ; return 0; }
function debug8()               { [ "$DebugFlag" = TRUE ] && echo 'DEBUG:        ' $* 1>&2 ; return 0; }
function debug12()              { [ "$DebugFlag" = TRUE ] && echo 'DEBUG:            ' $* 1>&2 ; return 0; }

function verbose()              { [ "$VerboseFlag" = TRUE ] && echo -n $* ; return 0; }
function verbosenl()            { [ "$VerboseFlag" = TRUE ] && echo $* ; return 0; }
function verboseSet()           { VerboseFlag=TRUE; return 0; }

# --- Exits

# function error()        { err 'ERROR:' $*; return 0; } # similar to err but with ERROR prefix and possibility to include
# Write an error message to stderr. We cannot use err here as the spaces would be removed.
function error()        { so on; echo 'ERROR:'$* 1>&2;            so off ; return 0; }
function error4()       { so on; echo 'ERROR:    '$* 1>&2;        so off ; return 0; }
function error8()       { so on; echo 'ERROR:        '$* 1>&2;    so off ; return 0; }
function error12()      { so on; echo 'ERROR:            '$* 1>&2;so off ; return 0; }

function warning()      { so on; echo 'WARNING:'$* 1>&2;          so off; return 0; }


function errorExit()    { EXITCODE=$1 ; shift; error $* ; exit $EXITCODE; }
function exitIfErr()    { a="$1"; b="$2"; shift; shift; [ "$a" -ne 0 ] && errorExit $b App returned $b $*; }

function err()          { echo $* 1>&2; }                 # just write to stderr
function err4()         { echo '   ' $* 1>&2; }           # just write to stderr
function err8()         { echo '       ' $* 1>&2; }       # just write to stderr
function err12()        { echo '           ' $* 1>&2; }   # just write to stderr

# --- Existence checks
function exitIfBinariesNotFound()       { for file in $@; do [ $(command -v "$file") ] || errorExit 253 binary not found: $file; done }
function exitIfPlainFilesNotExisting()  { for file in $*; do [ ! -f $file ] && errorExit 254 'plain file not found:'$file 1>&2; done }
function exitIfFilesNotExisting()       { for file in $*; do [ ! -e $file ] && errorExit 255 'file not found:'$file 1>&2; done }
function exitIfDirsNotExisting()        { for dir in $*; do [ ! -d $dir ] && errorExit 252 "$APP:ERROR:directory not found:"$dir; done }

# --- Temporary file/directory  creation
# -- file creation -- TMP1=$(tempFile); TMP2=$(tempFile) ;;;; trap "rm -f $TMP1 $TMP2" EXIT
# -- directory creation -- TMPDIR=$(tempDir) ;;;;;  trap "rm -fr $TMPDIR;" EXIT
#
function tempFile()                     { mktemp ${TMPDIR:-/tmp/}$_app.XXXXXXXX; }
function tempDir()                      { mktemp -d "${TMPDIR:-/tmp/}$_app.YYYYYYYYY"; }
# realpath as shell, argument either supplied as stdin or as $1

# application-specific functions  ===============================================================================

function usage()
{
    err DESCRIPTION
    err4 $_app allows for the encryption of files in a git repository. Solve some problems with
    err4 git crypt, git secret, and git secrets.
    err
    err SYNOPSIS
    err4 $_app '[-D] gee init <<pwFile>>'
    err8 Put git repository under git gee => install a prehook
    err8 and specify the password file for en- and decryption.
    err
    err4 $_app '( add | a )' '<<file>> ...'
    err8 - Put file under git.
    err8 - The current contents will be copied to '<<file>>.gee' and will be encrypted
    err8 - The current '<<file>>' will be put in .gitignore
    err8 - Potentially already existing version of '<<file>>' in index will be removed rm --cached
    err
    err4 $_app '(clean | c) [ -f | --force ]'
    err8 delete the unencrypted versions of gee files if they are older than the correspondig gee files.
    err8 In force mode, delete the unencrypted files even if they are younger thane the correspondig gee files.
    err
    err4 $_app '( unencrypt | u | un | unenc | unencr )' '<<file>> ...'
    err8 - creates an unencrypted version of the file. If no argument is given, it does so for all .gee files.
    err8 - No difference if the file is specified with .gee or without it.
    err
    err4 $_app '( e | enc | encr | encrypt)' '[ -f | --force ] <<file>> ...'
    err8 todo force mode?
    err8 - encrypts the specificied files.
    err8 - No difference if the file is specified with .gee or without it.
    err8 - -f force mode
    err
    err4 $_app '( list | lst | l )'
    err8 - list files under git gee
    err
    err4 $_app version
    err8 - list the current version of git gee and exits
    err
    err4 $_app '( help | h | -h )'
    err8 - show this help and exits with exit code 1.
    err
    err4 git commit '[ -n ]' ...
    err8 - gee checks for all .gee files if the ignored file without the suffix is younger than the .gee file
    err12   if existing. If so, it blocks the commit.
    err8 -n prevents the checks and commits anyway.
    err
    err4 GLOBAL OPTIONS
    err8 '-D      ::= enable debug output'
    err8 '-v      ::= verbose mode'
    err8 '-h      ::= show usage message and exit with exit code 1'
}

function parseCLI() {
    while getopts "Dhv" options; do         # Loop: Get the next option;
        case "${options}" in                    # TIMES=${OPTARG}
            D)  err Debug enabled ; debugSet
                ;;
            h)  usage ; exit 1
                ;;
            v)  verboseSet
                ;;
            *)  err Help with $_app -h
                exit 2  # Exit abnormally.
                ;;
        esac
    done
}

function checkPreCommitHookExisting() {
    readonly _hook=$gitroot/.git/hooks/pre-commit
    [ -e "$_hook" -a ! -f "$_hook" ] && error Other object type with name $_hook && return 1
    [ ! -f "$_hook" ] && error Hook $_hook not found. && return 2
    [ ! -r "$_hook" ] && error Hook $_hook not readable. && return 3
    return 0
}

function exitIfNotInGitRepo() {
    git rev-parse --show-toplevel &>/dev/null || errorExit 11 Not in a git repository
}

function exitIfNotInGitGeeRepo() {
    echo $gitroot/.git/gee
    [ ! -f $gitroot/.git/gee ] && errorExit 12 Not a git gee repository
}

function git-root-relative-path () {
    local absfile
    _absfile=$(readlink -f "$1")
    echo $_absfile | sed s,$gitroot/,,
}

function initDefaultVars() {
    declare -gr gitroot="$(git rev-parse --show-toplevel)"
    declare -gr gitignore="$gitroot/.gitignore"
    declare -gr geePwFile=$(dirname $gitroot)/$(basename $gitroot).gee.pw
    debug initDefaultVars gitroot $gitroot gitignore $gitignore geePwFile $geePwFile
}

function createPreCommit() {
    # single-quotes around ENDINIT prevents evaluation of vars inside here document
    cat  >| .git/hooks/pre-commit <<'ENDINIT'
#!/usr/bin/env bash

# --- debug: Conditional debugging. All commands begin w/ debug.

function debugSet()             { DebugFlag=TRUE; return 0; }
function debug()                { [ "$DebugFlag" = TRUE ] && echo 'DEBUG:'$* 1>&2 ; return 0; }

function initDefaultVars() {
    declare -gr gitroot="$(git rev-parse --show-toplevel)"
    declare -gr geePwFile=$(dirname "$gitroot")/$(basename "$gitroot").gee.pw
}

function main() {
    initDefaultVars
    cd "$gitroot"
    debug pre-commit starting from $(pwd)
    for file in $(find . -name '*.gee' -type f -print) ; do
        debug working on $file
        _noGeeFile=$(basename $file .gee)
        _noGeeDir=$(dirname $file)
        if [ -f "$_noGeeDir/$_noGeeFile"  ] ; then
            [ "$_noGeeDir/$_noGeeFile" -nt "$file"  ] && 1>&2 echo $file older than unencrypted file && exit 1
        fi
    done
}

main $*
ENDINIT
    res=$? && chmod 755 .git/hooks/pre-commit
    return $?
}

function initMode() {
    debug init mode
    exitIfNotInGitRepo
    initDefaultVars
    cd $gitroot
    [ ! -f $geePwFile ] && errorExit 30 Password file $geePwFile not found
    [ ! -r $geePwFile ] && errorExit 31 Password file $geePwFile not readable
    [ -f .gitignore ] && [ $(egrep '.gee$' .gitignore | wc -l) -gt 0 ] && errorExit 32 .gee files seem to be in .gitignore, please check
    [ -f .git/hooks/pre-commit ] && errorExit 33 pre-commit already existing.
    createPreCommit ; res=$?
    [ $res -eq 0 ] && touch $gitroot/.git/gee && return 0 # make it detectable that gee is applied
    return 39
}

function endecryptFile2() {
    debug encryptFile $*
    local _mode=$1 ; shift
    [ -z "$1" ] && errorExit 60 missing pw argument to encryptFile
    local _pw=$1
    shift
    [ -z "$1" ] && errorExit 61 missing file argument to encryptFile
    TMP1=$(tempFile) ; trap "/bin/rm -f $TMP1" EXIT
    for file in $* ; do
        /bin/cp -f $file $TMP1 ; [ $? -ne 0 ] && echo copying file error
        echo -n "Procssesing file $file "
        ansible-vault $_mode --vault-password-file $_pw $TMP1 ; [ $? -ne 0 ] && echo encrypting file error
        /bin/mv -f $TMP1 $file ; [ $? -ne 0 ] && echo moving processed file error
    done
}

function encryptFile() {
    endecryptFile2 encrypt $*
}

function decryptFile() {
    endecryptFile2 decrypt $*
}

function addMode() {
    debug add mode
    exitIfNotInGitRepo
    initDefaultVars
    exitIfNotInGitGeeRepo
    exitIfBinariesNotFound ansible-vault
    shift
    for file in $* ; do
        [ ! -e $file ] && errorExit 40 $file does not seem to exist
        [ ! -f $file ] && errorExit 41 $file is not a plain file
        [ -f $file.gee ] && errorExit 42 $file.gee already existing
        local gitFile=$(git-root-relative-path $file)
        if [ $(egrep $gitFile $gitignore 2>/dev/null | wc -l) -gt 0 ] ; then
            1>&2 echo WARNING: file $file already in .gitignore
            [ ! -f "$file.gee" ] && errorExit 43 File in gitignore but no related gee file found.
            continue
        fi
        echo $gitFile >> "$gitroot/.gitignore"
        git add "$gitroot/.gitignore"
        git rm --cached $file &>/dev/null # remove file if potentially in index
        cp $file $file.gee
        encryptFile $geePwFile $file.gee
        git add $file.gee
    done
}

function clearMode() {
    # todo
    initDefaultVars
}

function decryptModeFile() {
    local file=$1
    debug decryptModeFile processing file $file
    _basefile=$(basename $file .gee)    # make sure, we have the correspondig gee file
    _geefile=$_basefile.gee    # make sure, we have the correspondig gee file
    [ ! -f $_geefile ] && errorExit 70 decryptModeFile file $_geefile does not exist for decryption
    if [ ! -f $_basefile -o $_geefile -nt $_basefile -o "$_force" = TRUE ] ; then
        /bin/cp -f $_geefile $_basefile
        decryptFile $_basefile
        eval $(stat -s $_geefile)

    else
        1>&2 echo WARNING: not decrypting $_geefile as the correspondig unencrypted file is younger
    fi
}

function decryptMode() {
    debug decrypt mode
    exitIfNotInGitRepo
    initDefaultVars
    exitIfNotInGitGeeRepo
    exitIfBinariesNotFound ansible-vault
    shift
    if [ "$1" = -f -o "$1" = --force ] ; then _force=TRUE ; shift ; else _force= ; fi
        #git rev-parse --show-toplevel &>/dev/null || errorExit 1 Not in a git repository
    #cd "$gitroot"

    # checkPreCommitHookExisting ; res=$? ; [ $res -ne 0 ] && return $res

}

function encryptModeFile() {
    local file=$1
    debug encryptModeFile processing file $file
    _basefile=$(basename $file .gee)
    debug basefile is $_basefile
    if [ -f $_basefile ] ; then
        debug basefile existing
        if [ $_basefile -nt $file -o ! "$_force" = TRUE ] ; then
            echo -n Encrypting file $file ' '
            /bin/cp -f $_basefile $file
            encryptFile $geePwFile $file
            git add $file
        else
            echo $file newer than $_basefile
        fi
    else
        echo NO $_basefile for $file
    fi
}

function encryptMode() {
    debug encrypt mode
    exitIfNotInGitRepo
    initDefaultVars
    exitIfNotInGitGeeRepo
    exitIfBinariesNotFound ansible-vault
    shift
    if [ "$1" = -f -o "$1" = --force ] ; then _force=TRUE ; shift ; else _force= ; fi # in force mode, encrypt file anyway if unencrypted version exists
    if [ -z "$*" ] ; then # all gee file mode
        cd "$gitroot"
        for file in $(find . -type f -name '*.gee' -print) ; do
            encryptModeFile $file
        done
    else # specificed gee file mode
        for file in $* ; do
            encryptModeFile $file
        done
    fi
}

function listMode() {
    debug list mode
    shift
    exitIfNotInGitRepo
    initDefaultVars
    verbosenl Listing from from git root directory:$gitroot
    cd "$gitroot"
    find . -type f -name '*.gee'
}

function main() {
    exitIfBinariesNotFound tput basename dirname readlink git pwd
    parseCLI $*
    shift $(($OPTIND - 1))  # not working inside parseCLI
    debug args after CLI parsing are $*

    case $1 in
    a|add)
        addMode $*
        ;;
    c|clear)
        clearMode $*
        ;;
    h|help)
        usage
        exit 1
        ;;
    init)
        initMode $*
        ;;
    l|list|lst)
        listMode $*
        ;;
    e|en|enc|encr|encry|encryp|encrypt|encrypted)
        encryptMode $*
        ;;
    d|de|dec|decr|decry|decryp|decrypt|u|un|une|unen|unencr|unencry|unencryp|unencrypt|unencrypted)
        decryptMode $*
        ;;
    version)
        echo $_appVersion
        exit 0
        ;;
    *)  [ -z "$1" ] && exit 0
        errorExit 10 unknown sub-command to git gee $1
        ;;
    esac
}

main $*

# EOF
